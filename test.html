<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
    <title>wordrobe</title>
    
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="wordrobe">
    <link rel="apple-touch-icon" href="https://conizm3.github.io/wordrobe/images/wordrobe-icon.png">
    <link rel="icon" type="image/svg+xml" href="https://conizm3.github.io/wordrobe/images/wordrobe-icon.png">
    <meta property="og:title" content="wordrobe">
    <meta property="og:description" content="シンプルな英単語帳">
    <meta property="og:image" content="https://conizm3.github.io/wordrobe/images/wordrobe-ogp.png">
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/dexie@3.2.4/dist/dexie.min.js"></script>

    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-analytics-compat.js"></script>

    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;500;700&display=swap" rel="stylesheet">

    <style>
        :root {
            --bg-color: #F8FAFC;
            --text-main: #475569;
            --accent: #258FAF;
            --shadow-light: #FFFFFF;
            --shadow-dark: #E6EFF5;
            --safe-top: env(safe-area-inset-top, 20px);
            --safe-bottom: env(safe-area-inset-bottom, 20px);
        }
        
        body {
            font-family: 'Noto Sans JP', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-main);
            -webkit-tap-highlight-color: transparent;
            overscroll-behavior-y: none;
            -webkit-user-select: none;
            user-select: none;
            touch-action: manipulation;
        }

        .allow-select {
            -webkit-user-select: text !important;
            user-select: text !important;
        }

        #error-overlay {
            display: none;
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(255, 255, 255, 0.95);
            z-index: 9999;
            padding: 20px;
            color: #ef4444;
            font-family: monospace;
            overflow: auto;
        }

        input, textarea {
            font-size: 16px !important;
            -webkit-user-select: text !important;
            user-select: text !important;
            pointer-events: auto !important;
            transform: translate3d(0,0,0);
        }

        .h-screen-safe {
            height: 100vh;
            height: 100dvh;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
        }

        header.custom-header {
            width: 100%;
            margin: 0 !important;
            border-radius: 0 0 24px 24px !important;
            padding-top: calc(env(safe-area-inset-top, 0px) + 20px) !important;
            padding-bottom: 20px;
            padding-left: 20px;
            padding-right: 20px;
            height: auto !important;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: relative;
            z-index: 50;
            background: var(--bg-color);
            box-shadow: 4px 4px 8px var(--shadow-dark), -4px -4px 8px var(--shadow-light);
            transition: all 0.3s ease;
        }

        @media (min-width: 768px) {
            header.custom-header {
                padding-top: 24px !important;
                padding-bottom: 24px !important;
            }
        }

        nav.custom-nav {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            z-index: 50;
            background: var(--bg-color);
            padding-bottom: max(var(--safe-bottom), 15px) !important;
            padding-top: 10px;
            height: auto !important;
            min-height: 80px;
            border-radius: 24px 24px 0 0 !important;
            display: flex;
            justify-content: space-around;
            align-items: center;
            box-shadow: 0px -4px 10px var(--shadow-dark);
            margin: 0 !important;
        }

        main.custom-main {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            padding-bottom: calc(90px + var(--safe-bottom)) !important;
            position: relative;
            z-index: 0;
        }

        .neu-flat {
            background: var(--bg-color);
            box-shadow: 4px 4px 8px var(--shadow-dark), -4px -4px 8px var(--shadow-light);
            border-radius: 16px;
            border: none;
        }
        .neu-pressed {
            background: var(--bg-color);
            box-shadow: inset 3px 3px 6px var(--shadow-dark), inset -3px -3px 6px var(--shadow-light);
            border-radius: 12px;
        }
        .neu-btn {
            background: var(--bg-color);
            box-shadow: 3px 3px 6px var(--shadow-dark), -3px -3px 6px var(--shadow-light);
            border-radius: 12px;
            transition: transform 0.1s;
        }
        .neu-btn:active {
            box-shadow: inset 2px 2px 4px var(--shadow-dark), inset -2px -2px 4px var(--shadow-light);
            transform: scale(0.98);
        }
        .neu-input {
            background: var(--bg-color);
            box-shadow: inset 3px 3px 6px var(--shadow-dark), inset -3px -3px 6px var(--shadow-light);
            border-radius: 16px;
            outline: none;
            -webkit-appearance: none;
        }

        .fade-in { animation: fadeIn 0.4s ease-out forwards; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

        @keyframes toastFadeIn {
            from { opacity: 0; transform: translate(-50%, 20px); }
            to { opacity: 1; transform: translate(-50%, 0); }
        }
        .toast-anim {
            animation: toastFadeIn 0.4s ease-out forwards;
            left: 50%;
            transform: translate(-50%, 0);
        }
        
        .slide-in-right { animation: slideInRight 0.3s cubic-bezier(0.4, 0, 0.2, 1) forwards; }
        @keyframes slideInRight { from { opacity: 0; transform: translateX(50px); } to { opacity: 1; transform: translateX(0); } }
        
        .slide-out-left { animation: slideOutLeft 0.3s cubic-bezier(0.4, 0, 0.2, 1) forwards; }
        @keyframes slideOutLeft { from { opacity: 1; transform: translateX(0); } to { opacity: 0; transform: translateX(-50px); } }

        .slide-out-right { animation: slideOutRight 0.3s cubic-bezier(0.4, 0, 0.2, 1) forwards; }
        @keyframes slideOutRight { from { opacity: 1; transform: translateX(0); } to { opacity: 0; transform: translateX(50px); } }

        .slide-up { animation: slideUp 0.3s cubic-bezier(0.4, 0, 0.2, 1) forwards; }
        @keyframes slideUp { from { transform: translateY(100%); } to { transform: translateY(0); } }
        
        .card-flip { perspective: 1000px; }
        .card-inner { 
            transition: transform 0.6s cubic-bezier(0.4, 0.2, 0.2, 1); 
            transform-style: preserve-3d; 
            position: relative; 
            width: 100%; 
            height: 100%; 
            transform-origin: center center;
        }
        .card-front, .card-back { 
            backface-visibility: hidden; 
            -webkit-backface-visibility: hidden; 
            position: absolute; 
            width: 100%; 
            height: 100%; 
            top: 0; 
            left: 0;
        }
        .card-back { transform: rotateY(180deg); }
        .flipped .card-inner { transform: rotateY(180deg); }

        .no-scrollbar::-webkit-scrollbar { display: none; }
        .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
    </style>
</head>
<body>
    <div id="error-overlay">
        <h3 style="font-size: 1.2rem; margin-bottom: 1rem; border-bottom: 2px solid #ef4444; padding-bottom: 0.5rem;">⚠️ 起動エラーが発生しました</h3>
        <p id="error-message"></p>
        <p style="margin-top: 1rem; color: #666; font-size: 0.9rem;">この画面をスクリーンショットして管理者に報告するか、ページをリロードしてください。</p>
    </div>

    <div id="root"></div>

    <script>
        window.onerror = function(message, source, lineno, colno, error) {
            const overlay = document.getElementById('error-overlay');
            const msgEl = document.getElementById('error-message');
            if (overlay && msgEl) {
                overlay.style.display = 'block';
                msgEl.innerText = `Error: ${message}\nAt: ${source}:${lineno}:${colno}\n\n${error ? error.stack : ''}`;
            }
        };
    </script>

    <script type="text/babel">
        let db_firebase = null;
        let auth = null;
        let analytics = null;
        const isFirebaseAvailable = typeof firebase !== 'undefined';

        if (isFirebaseAvailable) {
            try {
                const firebaseConfig = {
                    apiKey: "AIzaSyCqoqNq7N-x5Wr6TsJkyCU0J6o-Mj1Ir8g",
                    authDomain: "conizm-01.firebaseapp.com",
                    projectId: "conizm-01",
                    storageBucket: "conizm-01.firebasestorage.app",
                    messagingSenderId: "180210157068",
                    appId: "1:180210157068:web:e03a373dd3f818cdee1029",
                    measurementId: "G-YD40SF3F32"
                };
                if (!firebase.apps.length) {
                    firebase.initializeApp(firebaseConfig);
                }
                db_firebase = firebase.firestore();
                auth = firebase.auth();
                analytics = firebase.analytics();
            } catch (e) {
                console.warn("Firebase Init Error:", e);
            }
        } else {
            console.warn("Firebase SDK not loaded. Running in offline mode.");
        }

        if (typeof Dexie === 'undefined') {
            throw new Error("Dexie.js library failed to load.");
        }
        const db = new Dexie('WordloopDB');
        db.version(3).stores({
            words: '++id, word, nextReview, interval, repetition, efactor, addedAt, folder',
            deleted_words: 'word'
        });

        if (typeof React === 'undefined' || typeof ReactDOM === 'undefined') {
            throw new Error("React library failed to load.");
        }
        const { useState, useEffect, useRef } = React;

        const fetchWithTimeout = async (url, options = {}, timeout = 15000) => {
            const controller = new AbortController();
            const id = setTimeout(() => controller.abort(), timeout);
            try {
                const response = await fetch(url, { ...options, signal: controller.signal });
                clearTimeout(id);
                return response;
            } catch (error) {
                clearTimeout(id);
                throw error;
            }
        };

        const translateText = async (text, langPair = "en|ja") => {
            if (!text) return null;
            const [source, target] = langPair.split('|');
            try {
                const res = await fetchWithTimeout(`https://lingva.ml/api/v1/${source}/${target}/${encodeURIComponent(text)}`, {}, 4000);
                if (!res.ok) return null;
                const data = await res.json();
                return data.translation;
            } catch (e) {
                console.warn("Translation failed or timed out", e);
                return null; 
            }
        };

        const isJapanese = (text) => /[\u3000-\u303f\u3040-\u309f\u30a0-\u30ff\uff00-\uff9f\u4e00-\u9faf\u3400-\u4dbf]/.test(text);

        const fetchAIExplanation = async (term, apiKey) => {
            if (!apiKey) return null;
            const cleanKey = apiKey.trim(); 

            const prompt = `「${term}」という言葉について、以下の情報をJSON形式で出力してください。Markdownのコードブロックは使わず、生のJSONテキストのみを返してください。
            キーは以下の通りです:
            "simpleTranslation": 最も一般的で頻度の高い日本語訳（単語〜短いフレーズ）。注意: 1. 'API'や'Browser'のような純粋な技術用語は、そのままカタカナや専門用語で訳してください。 2. ただし、'prompt'（迅速な vs コマンド入力）や'monitor'（監視する vs 画面）のように、一般的な意味と技術的意味の両方を持つ多義語の場合は、一般的な意味（日常・ビジネス）を優先してください。
            "spellCheck": 入力テキストにスペルミスがある場合は修正後の正しいスペルのみを出力してください（単語単体の場合も含む。例: 'appel'→'apple'）。ミスがない場合や固有名詞（例: Yasu）の場合は null を出力してください。
            "definition": 定義（日本語で簡潔に、10〜20語程度で）
            "exampleEn": 英語の例文1つ
            "exampleJa": 例文の日本語訳
            "supplement": 補足情報（ニュアンス、文脈、類語との違い、フォーマル度、誤用しやすい点などを含める）`;
            
            const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${cleanKey}`;

            const callApi = async (retryCount = 0) => {
                try {
                    const res = await fetchWithTimeout(url, {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] })
                    }, 15000);

                    if (!res.ok) {
                        if ((res.status === 503 || res.status === 429) && retryCount < 2) {
                            const delay = Math.pow(2, retryCount) * 1000; 
                            await new Promise(resolve => setTimeout(resolve, delay));
                            return callApi(retryCount + 1);
                        }
                        const errorData = await res.json().catch(() => ({}));
                        if (res.status === 400 && (JSON.stringify(errorData).includes('API key') || JSON.stringify(errorData).includes('INVALID_ARGUMENT'))) {
                            return { error: "ERROR_API_KEY" }; 
                        }
                        return null;
                    }
                    const data = await res.json();
                    let text = null;
                    if (data?.candidates?.[0]?.content?.parts?.[0]) {
                        text = data.candidates[0].content.parts[0].text;
                    }
                    
                    if (text) {
                        try {
                            const fence = "`" + "`" + "`";
                            const jsonBlockPattern = new RegExp(fence + 'json', 'g');
                            const codeBlockPattern = new RegExp(fence, 'g');
                            const jsonStr = text.replace(jsonBlockPattern, '').replace(codeBlockPattern, '').trim();
                            return JSON.parse(jsonStr);
                        } catch (e) { return null; }
                    }
                    return null;
                } catch (e) {
                    if (retryCount < 2) {
                        const delay = Math.pow(2, retryCount) * 1000;
                        await new Promise(resolve => setTimeout(resolve, delay));
                        return callApi(retryCount + 1);
                    }
                    return null;
                }
            };
            return callApi();
        };

        const fetchJishoData = async (term) => {
            try {
                const res = await fetchWithTimeout(`https://api.allorigins.win/raw?url=${encodeURIComponent(`https://jisho.org/api/v1/search/words?keyword=${encodeURIComponent(term)}`)}`, {}, 4000);
                if (!res.ok) return null;
                return await res.json();
            } catch (e) { return null; }
        };

        const fetchFreeDictData = async (term) => {
            try {
                const res = await fetchWithTimeout(`https://api.dictionaryapi.dev/api/v2/entries/en/${encodeURIComponent(term)}`, {}, 4000);
                if (!res.ok) return null;
                return await res.json();
            } catch (e) { return null; }
        };

        const searchCache = new Map();

        const fetchRichData = async (term) => {
            if (searchCache.has(term)) return searchCache.get(term);

            let searchWord = term, isJpSearch = isJapanese(term), tips = "公開辞書/翻訳データ", primaryTrans = "", meanings = [], pronunciation = "", synonyms = [], audioUrl = "", jishoFound = false;

            try {
                const jishoData = await fetchJishoData(term);
                if (jishoData && jishoData.data && jishoData.data.length > 0) {
                    jishoFound = true;
                    tips = "Jisho.org";
                    if (isJpSearch) {
                        const entry = jishoData.data[0];
                        const englishDef = entry.senses[0].english_definitions[0];
                        
                        const translated = await translateText(term, "ja|en");
                        
                        if (translated && translated !== term) {
                            searchWord = translated;
                        } else {
                            searchWord = englishDef;
                        }
                        
                        primaryTrans = term;
                        pronunciation = entry.japanese[0].reading || "";
                        entry.senses.slice(0, 3).forEach(s => meanings.push({ partOfSpeech: s.parts_of_speech.join(', ') || 'Common', definitions: [{ ja: s.english_definitions.join('; '), en: "", exEn: "", exJa: "" }] }));
                    } else {
                        let entries = jishoData.data;
                        const searchKeywords = term.toLowerCase().split(/\s+/).filter(w => !['a', 'the', 'to'].includes(w));
                        if (searchKeywords.length > 0) {
                            const filtered = entries.filter(entry => 
                                searchKeywords.every(kw => JSON.stringify(entry).toLowerCase().includes(kw))
                            );
                            if (filtered.length > 0) entries = filtered;
                        }
                        entries = entries.slice(0, 5);
                        primaryTrans = entries[0].japanese[0].word || entries[0].japanese[0].reading;
                        entries.forEach(e => {
                            const w = e.japanese[0].word || e.japanese[0].reading;
                            const r = e.japanese[0].reading;
                            const defJa = (r && r !== w) ? `${w} (${r})` : w;
                            const engDefs = e.senses.map(s => s.english_definitions.join(', ')).join('; ');
                            const pos = e.senses[0].parts_of_speech.join(', ') || 'Common';
                            meanings.push({ partOfSpeech: pos, definitions: [{ ja: defJa, en: engDefs, exEn: "", exJa: "" }] });
                        });
                        searchWord = term;
                    }
                }
            } catch (e) {}

            if (!jishoFound) {
                if (!isJpSearch && !term.trim().includes(' ')) {
                     const fd = await fetchFreeDictData(term);
                     if (!fd || fd.length === 0) throw new Error("NOT_FOUND");
                }
                
                let trans = await translateText(term, isJpSearch ? "ja|en" : "en|ja");
                
                if (!trans || trans === term) {
                    throw new Error("NOT_FOUND");
                }
                
                searchWord = isJpSearch ? trans : term;
                primaryTrans = isJpSearch ? term : trans;
                meanings.push({ partOfSpeech: "Translation", definitions: [{ ja: primaryTrans, en: "", exEn: "", exJa: "" }] });
                tips = "翻訳ソフト";
            }

            const resultData = { word: searchWord, translation: primaryTrans, meanings, pronunciation, synonyms: [], audioUrl: "", definition: meanings[0]?.definitions[0]?.ja || primaryTrans, example: "", tips };
            searchCache.set(term, resultData);
            return resultData;
        };

        const fetchEnrichment = async (currentData, term) => {
            const searchWord = currentData.word;
            const isJpSearch = isJapanese(term);
            try {
                const dictData = await fetchFreeDictData(searchWord);
                if (!dictData || dictData.length === 0) return null;
                const entry = dictData[0];
                const newData = { ...currentData };
                const p = entry.phonetics.find(p => p.audio && p.audio !== "");
                if (p) newData.audioUrl = p.audio;
                if (!newData.pronunciation && !isJpSearch) newData.pronunciation = entry.phonetic || "";
                newData.synonyms = entry.meanings.flatMap(m => m.synonyms).slice(0, 5);
                return newData;
            } catch(e) { return null; }
        };

        let englishVoices = [];
        const loadVoices = () => {
            const voices = window.speechSynthesis.getVoices();
            englishVoices = voices.filter(v => v.lang.startsWith('en'));
        };

        loadVoices();
        if (window.speechSynthesis.onvoiceschanged !== undefined) {
            window.speechSynthesis.onvoiceschanged = loadVoices;
        }

        const speak = (text, audioUrl = null) => {
            if (audioUrl) {
                new Audio(audioUrl).play().catch(e => console.error("Audio play failed", e));
                return;
            }
            if (!text) return;
            window.speechSynthesis.cancel();
            const ut = new SpeechSynthesisUtterance(text);
            ut.lang = 'en-US';
            if (englishVoices.length === 0) loadVoices(); 
            const preferredVoice = englishVoices.find(v => v.name === 'Google US English') || 
                                   englishVoices.find(v => v.lang === 'en-US') || 
                                   englishVoices.find(v => v.lang === 'en-GB') || 
                                   englishVoices[0];
            if (preferredVoice) {
                ut.voice = preferredVoice;
            }
            window.speechSynthesis.speak(ut);
        };

        const Toast = ({ msg, onClose }) => {
            useEffect(() => {
                const timer = setTimeout(onClose, 3000);
                return () => clearTimeout(timer);
            }, []);
            return (
                <div className="fixed bottom-32 left-1/2 toast-anim neu-flat px-6 py-3 rounded-full text-sm text-[#258FAF] font-bold z-[100] shadow-lg text-center whitespace-nowrap bg-white border border-gray-100">
                    {msg}
                </div>
            );
        };

        const FolderSelectModal = ({ isOpen, onClose, folders, onSelectFolder, onCreateFolder }) => {
            const [newFolder, setNewFolder] = useState('');

            if (!isOpen) return null;

            const handleCreate = () => {
                if (newFolder.trim()) {
                    onCreateFolder(newFolder.trim());
                    setNewFolder('');
                }
            };

            return (
                <div className="fixed inset-0 z-[90] flex items-end justify-center">
                    <div className="absolute inset-0 bg-black/20 backdrop-blur-sm transition-opacity" onClick={onClose}></div>
                    <div className="relative bg-[#F8FAFC] w-full max-w-md rounded-t-3xl p-4 shadow-2xl slide-up border-t border-white/50 pb-8">
                        <button onClick={onClose} className="absolute top-4 right-4 text-gray-400 hover:text-gray-600 p-2 z-10">
                            <i className="fas fa-times text-lg"></i>
                        </button>
                        
                        <h3 className="text-lg font-bold text-[#258FAF] mb-4 flex items-center gap-2 mt-2 ml-1">
                            <i className="fas fa-folder-open"></i> フォルダを選択
                        </h3>
                        
                        <div className="space-y-3 mb-6 max-h-[40vh] overflow-y-auto no-scrollbar py-1">
                            {folders.map(folder => (
                                <button key={folder} onClick={() => onSelectFolder(folder)} className="w-full text-left p-4 rounded-xl neu-flat hover:bg-gray-50 flex justify-between items-center transition-transform active:scale-[0.99]">
                                    <span className="font-bold text-gray-700">{folder}</span>
                                    <i className="fas fa-chevron-right text-gray-300 text-xs"></i>
                                </button>
                            ))}
                        </div>

                        <div className="flex gap-2 w-full">
                            <input 
                                type="text" 
                                value={newFolder}
                                onChange={(e) => setNewFolder(e.target.value)}
                                placeholder="新しいフォルダを作成..."
                                className="neu-input flex-1 p-3 text-sm min-w-0"
                            />
                            <button onClick={handleCreate} disabled={!newFolder.trim()} className="bg-[#258FAF] text-white px-4 rounded-xl font-bold text-sm disabled:opacity-50 shadow-md whitespace-nowrap shrink-0">
                                作成
                            </button>
                        </div>
                    </div>
                </div>
            );
        };

        const FolderManagerModal = ({ isOpen, onClose, folders, onRename, onDelete }) => {
            const [editingFolder, setEditingFolder] = useState(null);
            const [editName, setEditName] = useState('');

            if (!isOpen) return null;

            const handleStartEdit = (folder) => {
                setEditingFolder(folder);
                setEditName(folder);
            };

            const handleSaveEdit = () => {
                if (editName.trim() && editName !== editingFolder) {
                    onRename(editingFolder, editName.trim());
                }
                setEditingFolder(null);
                setEditName('');
            };

            const handleDelete = (folder) => {
                onDelete(folder);
            };

            return (
                <div className="fixed inset-0 z-[95] flex items-end justify-center">
                    <div className="absolute inset-0 bg-black/20 backdrop-blur-sm transition-opacity" onClick={onClose}></div>
                    <div className="relative bg-[#F8FAFC] w-full max-w-md rounded-t-3xl p-4 shadow-2xl slide-up border-t border-white/50 pb-8">
                        <button onClick={onClose} className="absolute top-4 right-4 text-gray-400 hover:text-gray-600 p-2 z-10">
                            <i className="fas fa-times text-lg"></i>
                        </button>
                        
                        <h3 className="text-lg font-bold text-[#258FAF] mb-4 flex items-center gap-2 mt-2 ml-1">
                            <i className="fas fa-cog"></i> フォルダ管理
                        </h3>
                        
                        <div className="space-y-3 mb-6 max-h-[50vh] overflow-y-auto no-scrollbar py-1">
                            {folders.map(folder => (
                                <div key={folder} className="w-full text-left p-4 rounded-xl neu-flat flex justify-between items-center">
                                    {editingFolder === folder ? (
                                        <div className="flex-1 flex gap-2 mr-2">
                                            <input 
                                                type="text" 
                                                value={editName} 
                                                onChange={(e) => setEditName(e.target.value)}
                                                className="neu-input flex-1 p-2 text-sm"
                                                autoFocus
                                            />
                                            <button onClick={handleSaveEdit} className="text-[#258FAF] p-2"><i className="fas fa-check"></i></button>
                                        </div>
                                    ) : (
                                        <span className="font-bold text-gray-700 flex-1">{folder}</span>
                                    )}
                                    
                                    {folder !== 'main' && editingFolder !== folder && (
                                        <div className="flex gap-2">
                                            <button onClick={() => handleStartEdit(folder)} className="w-8 h-8 rounded-full neu-pressed text-gray-400 hover:text-[#258FAF] flex items-center justify-center">
                                                <i className="fas fa-pen text-xs"></i>
                                            </button>
                                            <button onClick={() => handleDelete(folder)} className="w-8 h-8 rounded-full neu-pressed text-gray-400 hover:text-red-500 flex items-center justify-center">
                                                <i className="fas fa-trash text-xs"></i>
                                            </button>
                                        </div>
                                    )}
                                    {folder === 'main' && <span className="text-xs text-gray-400 bg-gray-100 px-2 py-1 rounded">Default</span>}
                                </div>
                            ))}
                        </div>
                    </div>
                </div>
            );
        };

        const DialogModal = ({ isOpen, type, message, onConfirm, onCancel }) => {
            if (!isOpen) return null;
            return (
                <div className="fixed inset-0 bg-slate-100/90 z-[80] flex items-center justify-center p-4 backdrop-blur-sm fade-in">
                    <div className="neu-flat bg-[#F8FAFC] p-6 w-full max-w-xs text-center border border-white">
                        <p className="text-gray-700 font-bold mb-6 leading-relaxed whitespace-pre-wrap text-sm">{message}</p>
                        <div className="flex gap-4 justify-center">
                            {type === 'confirm' && (
                                <button onClick={onCancel} className="neu-btn w-24 py-3 text-gray-500 font-bold text-xs rounded-xl">キャンセル</button>
                            )}
                            <button onClick={onConfirm} className="bg-[#258FAF] text-white w-24 py-3 rounded-xl font-bold text-xs shadow-lg active:scale-95 transition-transform">OK</button>
                        </div>
                    </div>
                </div>
            );
        };

        const TOSModal = ({ onAgree, isVisible }) => {
            if (!isVisible) return null;

            const tosUrl = "https://maze-dracorex-e48.notion.site/Terms-of-use-2c404d09b6cc803bad7bd012f0deed88?pvs=73"; 

            return (
                <div className="fixed inset-0 bg-slate-100/95 z-[100] flex items-center justify-center p-4 backdrop-blur-sm fade-in">
                    <div className="neu-flat bg-[#F8FAFC] p-5 w-full max-w-xs text-center border border-white max-h-[80vh] overflow-y-auto">
                        <h2 className="text-lg font-bold text-[#258FAF] mb-3">ご利用規約への同意</h2>                
                        <div className="text-left text-xs text-gray-700 space-y-3 mb-5">
                            <p>本アプリのご利用前に、以下の事項をご確認いただき、同意をお願いいたします。</p>
                            <p className="font-bold text-[#258FAF]">【重要】知的財産権について</p>
                            <div className="text-xs ml-2 border-l-2 border-[#258FAF]/50 pl-2 bg-[#258FAF]/5 py-2">
                                本アプリを通じて提供されるすべてのコンテンツ（デザイン、データ等）の著作権を含む知的財産権は、開発者に帰属します。
                                <br/>これらのコンテンツの無断での複製、転載、配布、二次利用は禁止いたします。
                            </div>
                            
                            <p>本アプリの利用をもって、規約に同意したものとみなされます。</p>
                        </div>
                        
                        <div className="flex flex-col gap-3">
                            <a href={tosUrl} target="_blank" rel="noopener noreferrer" className="text-xs text-[#258FAF] hover:text-[#1d6f8c] underline font-bold">
                                <i className="fas fa-file-alt mr-1"></i> 利用規約全文を読む (外部サイトへ)
                            </a>

                            <button 
                                onClick={onAgree} 
                                className="bg-[#258FAF] text-white w-full py-2.5 rounded-xl font-bold text-xs shadow-lg active:scale-95 transition-transform"
                            >
                                同意してアプリを利用する
                            </button>
                            
                            <p className="text-[9px] text-gray-400 mt-1">
                                ボタンを押すことで、利用規約に同意したものとみなされます。
                            </p>
                        </div>
                    </div>
                </div>
            );
        };

        const SettingsModal = ({ isOpen, onClose, onExport, onImport, user, onLogin, onLogout, openAlert, openConfirm }) => {
            const [apiKey, setApiKey] = useState('');
            const [isSaved, setIsSaved] = useState(false);
            const [testStatus, setTestStatus] = useState(null);

            useEffect(() => {
                if (isOpen) {
                    const storedKey = localStorage.getItem('gemini_apikey');
                    if (storedKey) {
                        setApiKey(storedKey);
                        setIsSaved(true);
                    } else {
                        setApiKey('');
                        setIsSaved(false);
                    }
                    setTestStatus(null);
                }
            }, [isOpen]);

            const handleKeyAction = () => {
                if (isSaved) {
                    openConfirm("APIキーを削除しますか？\n（入力されたキーはこの端末から消去されます）", () => {
                        localStorage.removeItem('gemini_apikey');
                        setApiKey('');
                        setIsSaved(false);
                        setTestStatus(null);
                    });
                } else {
                    const cleanKey = apiKey.trim();
                    if (!cleanKey) return openAlert('APIキーを入力してください');
                    
                    localStorage.setItem('gemini_apikey', cleanKey);
                    setApiKey(cleanKey);
                    setIsSaved(true);
                }
            };
            
            const handleTestConnection = async () => {
                const cleanKey = apiKey.trim();
                if (!cleanKey) {
                    openAlert('APIキーを入力してください');
                    return;
                }
                setTestStatus('testing');
                try {
                    const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${cleanKey}`;
                    const res = await fetchWithTimeout(url, {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({ contents: [{ parts: [{ text: "Hello" }] }] })
                    }, 15000);
                    
                    if (res.ok) {
                        setTestStatus('success');
                        openAlert('接続成功！\nAPIは正しく動作しています。');
                    } else {
                        setTestStatus('error');
                        openAlert('接続エラー');
                    }
                } catch (e) {
                    setTestStatus('error');
                    openAlert(`ネットワークエラー\n${e.message}`);
                }
            };

            if (!isOpen) return null;
            return (
                <div className="fixed inset-0 bg-slate-100/90 z-[60] flex items-center justify-center p-4 backdrop-blur-sm fade-in">
                    <div className="neu-flat bg-[#F8FAFC] p-6 w-full max-w-md max-h-[90vh] overflow-y-auto border border-white">
                        <div className="flex justify-between items-center mb-6">
                            <div className="flex items-center gap-2">
                                <h2 className="text-lg font-bold text-[#258FAF]">設定</h2>
                                <a href="https://maze-dracorex-e48.notion.site/wordrobe-Help-Guide-2bf04d09b6cc80248eebd66c3fcb284b" target="_blank" rel="noopener noreferrer" className="flex items-center mt-[1px] text-[#258FAF]/60 hover:text-[#258FAF] transition-colors">
                                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                                        <circle cx="12" cy="12" r="10"></circle>
                                        <path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path>
                                        <line x1="12" y1="17" x2="12.01" y2="17"></line>
                                    </svg>
                                </a>
                            </div>
                            <button onClick={onClose} className="text-gray-400 hover:text-gray-600"><i className="fas fa-times"></i></button>
                        </div>
                        
                        <div className="mb-6 border-b border-gray-200 pb-6">
                            <div className="flex flex-col mb-3">
                                <div className="flex items-center gap-2">
                                    <h3 className="text-sm font-bold text-gray-500 flex items-center gap-2"><i className="fas fa-robot text-gray-500"></i> AI機能設定 (Gemini)</h3>
                                </div>
                                <p className="text-[10px] text-gray-400 mt-1 ml-6 leading-relaxed">APIキーを設定すると、AIによる翻訳、解説が追加されます。</p>
                                <p className="text-[9px] text-gray-400 mt-0.5 ml-6 leading-relaxed">※APIキーは利用者のブラウザにのみ保存され、外部送信はされません。</p>
                                <p className="text-[9px] text-gray-400 mt-0.5 ml-6 leading-relaxed">※ネットカフェなど共有パソコンでは、使用後必ず削除してください</p>
                            </div>
                            <div className="neu-flat p-4 rounded-xl">
                                <div className="flex flex-col sm:flex-row gap-2">
                                    <input 
                                        type="password" 
                                        value={apiKey}
                                        disabled={isSaved}
                                        onChange={(e) => setApiKey(e.target.value)}
                                        placeholder={isSaved ? "設定済み" : "APIキーを入力"} 
                                        className={`neu-input flex-1 p-2 text-sm min-w-0 transition-colors ${isSaved ? "bg-gray-100 text-gray-400" : ""}`}
                                    />
                                    <button 
                                        onClick={handleKeyAction} 
                                        className={`px-3 py-2 rounded-lg text-xs font-bold shadow-md transition-colors whitespace-nowrap min-w-[80px] flex items-center justify-center gap-1 ${
                                            isSaved ? 'bg-red-500 hover:bg-red-600 text-white' : 'bg-[#258FAF] text-white'
                                        }`}
                                    >
                                        {isSaved ? (
                                            <React.Fragment>
                                                <i className="fas fa-trash"></i> 削除
                                            </React.Fragment>
                                        ) : (
                                            '設定'
                                        )}
                                    </button>
                                </div>
                                <div className="mt-3 flex justify-center items-center gap-4">
                                    <a href="https://aistudio.google.com/app/apikey" target="_blank" rel="noopener noreferrer" className="text-xs text-[#258FAF] hover:text-[#1d6f8c] flex items-center gap-1">
                                        <i className="fas fa-key"></i> <span className="underline">APIキー取得</span>
                                    </a>
                                    <button onClick={handleTestConnection} className="text-xs text-[#258FAF] hover:text-[#1d6f8c] inline-flex items-center gap-1">
                                        {testStatus === 'testing' ? <i className="fas fa-spinner fa-spin"></i> : <i className="fas fa-plug"></i>}
                                        <span className="underline">接続テスト</span>
                                    </button>
                                </div>
                            </div>
                        </div>

                        <div className="mb-6 border-b border-gray-200 pb-6">
                            <div className="flex flex-col mb-3">
                                <div className="flex items-center gap-2">
                                    <h3 className="text-sm font-bold text-gray-500 flex items-center gap-2"><i className="fas fa-cloud text-gray-500"></i> クラウド同期</h3>
                                </div>
                                <p className="text-[10px] text-gray-400 mt-1 ml-6 leading-relaxed">ログインすると、単語棚データが自動で保存/同期されるようになります。</p>
                            </div>
                            <div>
                                {user ? (
                                    <div className="neu-pressed bg-[#258FAF]/5 p-4 rounded-xl border border-[#258FAF]/20 relative overflow-hidden text-center">
                                        <p className="text-sm text-[#258FAF] font-bold mb-2">ログイン中</p>
                                        <p className="text-xs text-gray-500 mb-3">{user.email || user.uid}</p>
                                        <button onClick={onLogout} className="bg-white text-red-500 border border-red-200 px-4 py-2 rounded-lg text-xs font-bold shadow-sm">ログアウト</button>
                                    </div>
                                ) : (
                                    <button onClick={onLogin} className="w-full neu-btn text-gray-700 font-bold p-3 rounded-xl shadow-sm flex items-center justify-center gap-2 hover:bg-gray-50">
                                        <svg className="w-5 h-5" viewBox="0 0 24 24"><path d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z" fill="#4285F4" /><path d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z" fill="#34A853" /><path d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z" fill="#FBBC05" /><path d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z" fill="#EA4335" /></svg>
                                        Googleでログイン
                                    </button>
                                )}
                            </div>
                        </div>
                        <div>
                            <div className="flex flex-col mb-3">
                                <div className="flex items-center gap-2">
                                    <h3 className="text-sm font-bold text-gray-500 flex items-center gap-2"><i className="fas fa-save text-gray-500"></i> ローカルバックアップ</h3>
                                </div>
                                <p className="text-[10px] text-gray-400 mt-1 ml-6 leading-relaxed">単語棚データをローカルに保存/復元します。</p>
                                <p className="text-[9px] text-gray-400 mt-0.5 ml-6 leading-relaxed">※クラウド同期しない場合は、定期的に保存することをおすすめします。</p>
                            </div>
                            <div className="flex gap-3">
                                <button onClick={onExport} className="flex-1 neu-btn p-3 text-xs font-bold text-gray-600 hover:text-[#258FAF] flex flex-col items-center gap-1"><i className="fas fa-file-export text-lg"></i>保存 (DL)</button>
                                <label className="flex-1 neu-btn p-3 text-xs font-bold text-gray-600 hover:text-[#258FAF] flex flex-col items-center gap-1 cursor-pointer"><input type="file" accept=".json" className="hidden" onChange={onImport} /><i className="fas fa-file-import text-lg"></i>復元</label>
                            </div>
                        </div>
                        
                        <div className="mt-8 flex flex-col items-center gap-4">
                            <div className="flex gap-3 w-full">
                                <a 
                                    href="https://buymeacoffee.com/conizm" 
                                    target="_blank" 
                                    rel="noopener noreferrer"
                                    className="bg-[#258FAF] text-white flex-1 group inline-flex justify-center items-center gap-2.5 px-4 py-3 rounded-xl text-sm font-bold shadow-sm hover:opacity-90 transition-all duration-300 ease-out"
                                >
                                    <svg 
                                        xmlns="http://www.w3.org/2000/svg" 
                                        className="w-5 h-5 text-white" 
                                        viewBox="0 0 24 24" 
                                        fill="none" 
                                        stroke="currentColor" 
                                        strokeWidth="2" 
                                        strokeLinecap="round" 
                                        strokeLinejoin="round"
                                    >
                                        <path d="M18 8h1a4 4 0 0 1 0 8h-1" />
                                        <path d="M2 8h16v9a4 4 0 0 1-4 4H6a4 4 0 0 1-4-4V8z" />
                                        <path d="M6 1c0 2 2 2 2 4" opacity="0.7" />
                                        <path d="M10 1c0 2 2 2 2 4" opacity="0.9" />
                                        <path d="M14 1c0 2 2 2 2 4" opacity="0.7" />
                                    </svg>
                                    <span className="tracking-wide font-bold">Buy Me a Coffee</span>
                                </a>
                                <a 
                                    href="https://www.instagram.com/conizm_/" 
                                    target="_blank" 
                                    rel="noopener noreferrer"
                                    className="neu-btn w-12 h-12 flex items-center justify-center rounded-xl text-[#258FAF] hover:text-[#C13584] transition-colors duration-300"
                                >
                                    <i className="fab fa-instagram text-2xl"></i>
                                </a>
                            </div>

                            <div className="flex flex-col items-center gap-1">
                                <a href="https://wordrobe.cc/" target="_blank" rel="noopener noreferrer" className="text-[10px] text-gray-400 hover:text-gray-600 border-b border-transparent hover:border-gray-600 transition-colors mb-1">アプリ概要 / プライバシーポリシー</a>
                                <p className="text-[10px] text-gray-300 font-mono">
                                    &copy; 2025 conizm_ 
                                    <a href="https://maze-dracorex-e48.notion.site/2c504d09b6cc806a8bdbeb3b6d2438f6?pvs=73" target="_blank" rel="noopener noreferrer" className="hover:text-gray-500 transition-colors">v.1.2.0</a>
                                </p>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        const SearchView = ({ onSaveWord, savedWords, setToast, externalResult, setExternalResult, isFromList, onBack, openAlert, onUpdateWord }) => {
            const [term, setTerm] = useState('');
            const [loading, setLoading] = useState(false);
            const [isEnriching, setIsEnriching] = useState(false); 
            const [aiError, setAiError] = useState(null);
            const resultRef = useRef(null);
            const searchIdRef = useRef(0);
            const isDataRichRef = useRef(false);
            const isMounted = useRef(true);
            const inputRef = useRef(null);
            
            const hasApiKey = !!localStorage.getItem('gemini_apikey');

            useEffect(() => {
                isMounted.current = true;
                if (inputRef.current && !isFromList) inputRef.current.focus();
                return () => { isMounted.current = false; };
            }, []);
            
            const executeSearch = async (searchTerm) => {
                if (!searchTerm.trim()) return;

                const currentId = ++searchIdRef.current;
                isDataRichRef.current = false;

                setLoading(true);
                setIsEnriching(true); 
                setExternalResult(null);
                setTerm(searchTerm);
                setAiError(null);

                try {
                    const coreData = await fetchRichData(searchTerm);
                    onUpdateWord(coreData);

                    if (isMounted.current && currentId === searchIdRef.current) {
                        setExternalResult(coreData);
                        isDataRichRef.current = true;
                        setLoading(false);

                        const enrichPromise = fetchEnrichment(coreData, searchTerm);
                        const apiKey = localStorage.getItem('gemini_apikey');
                        const aiPromise = apiKey ? fetchAIExplanation(coreData.word, apiKey) : Promise.resolve(null);

                        Promise.all([enrichPromise, aiPromise]).then(([enriched, aiData]) => {
                            if (!isMounted.current || currentId !== searchIdRef.current) return;
                            let newData = { ...coreData };
                            let hasUpdate = false;
                            if (enriched) { newData = { ...newData, ...enriched }; hasUpdate = true; }
                            
                            if (aiData) {
                                if (aiData.error === "ERROR_API_KEY") {
                                    setAiError('AI接続エラー。\nAPIキーが無効のようです。');
                                } else { 
                                    if (aiData.spellCheck) {
                                        openAlert(`⚠️ もしかして: ${aiData.spellCheck} ?\n正しいスペルで検索し直します。`);
                                        executeSearch(aiData.spellCheck);
                                        return;
                                    }

                                    newData = { ...newData, aiData: aiData }; 
                                    if (aiData.simpleTranslation) {
                                        newData.translation = aiData.simpleTranslation;
                                    }
                                    hasUpdate = true; 
                                }
                            } else if (hasApiKey) {
                                setAiError('AI接続エラー。\nAPIキーが間違っているか、使用上限などの関係でAIに接続できません。');
                            }

                            if (hasUpdate) { setExternalResult(newData); onUpdateWord(newData); }
                        }).catch(() => {
                             if (isMounted.current && currentId === searchIdRef.current && hasApiKey) {
                                 setAiError('AI接続エラー。\nAPIキーが間違っているか、使用上限などの関係でAIに接続できません。');
                             }
                        }).finally(() => { 
                             if (isMounted.current && currentId === searchIdRef.current) setIsEnriching(false); 
                        });
                    }
                } catch (err) {
                    if (isMounted.current && currentId === searchIdRef.current) {
                        if (hasApiKey) {
                             const apiKey = localStorage.getItem('gemini_apikey');
                             fetchAIExplanation(searchTerm, apiKey).then(aiData => {
                                 if (isMounted.current && currentId === searchIdRef.current) {
                                     if (aiData && aiData.spellCheck) {
                                         openAlert(`⚠️ もしかして: ${aiData.spellCheck} ?\n正しいスペルで検索し直します。`);
                                         executeSearch(aiData.spellCheck);
                                     } else {
                                         setLoading(false);
                                         setIsEnriching(false);
                                         if (err.message === "NOT_FOUND") openAlert('見つかりませんでした');
                                         else openAlert('検索エラーが発生しました');
                                     }
                                 }
                             }).catch(() => {
                                 if (isMounted.current && currentId === searchIdRef.current) {
                                     setLoading(false);
                                     setIsEnriching(false);
                                     if (err.message === "NOT_FOUND") openAlert('見つかりませんでした');
                                     else openAlert('検索エラーが発生しました');
                                 }
                             });
                        } else {
                            setLoading(false);
                            setIsEnriching(false);
                            if (err.message === "NOT_FOUND") openAlert('見つかりませんでした');
                            else openAlert('検索エラーが発生しました');
                        }
                    }
                }
            };
            
            const handleSearch = async (e) => {
                if (e) e.preventDefault();
                executeSearch(term);
            };
            
            useEffect(() => {
                const performSilentUpdate = async () => {
                    if (!isFromList || !externalResult || externalResult.aiData || !hasApiKey) {
                        return;
                    }

                    try {
                        const term = externalResult.word;
                        const apiKey = localStorage.getItem('gemini_apikey');
                        
                        const [coreData, aiData] = await Promise.all([
                            fetchRichData(term),
                            fetchAIExplanation(term, apiKey)
                        ]);

                        if (!aiData || aiData.error) {
                             if (isMounted.current) setAiError('AI接続エラー。\nAPIキーが間違っているか、使用上限などの関係でAIに接続できません。');
                             return;
                        }
                        
                        if (!isMounted.current) return;

                        let newData = { ...coreData };
                        
                        newData.aiData = aiData;
                        
                        if (aiData.simpleTranslation) {
                            newData.translation = aiData.simpleTranslation;
                        }

                        const enriched = await fetchEnrichment(newData, term);
                        if (enriched) {
                            newData = { ...newData, ...enriched };
                        }

                        if (!isMounted.current) return;

                        onUpdateWord(newData);
                        setExternalResult(newData);
                        setToast('AI解説を追加しました');
                        setAiError(null);

                    } catch (e) {
                        if (isMounted.current) setAiError('AI接続エラー。\nAPIキーが間違っているか、使用上限などの関係でAIに接続できません。');
                        console.log("Silent update failed silently:", e);
                    }
                };

                performSilentUpdate();
            }, [externalResult, isFromList, hasApiKey, onUpdateWord]);

            useEffect(() => { if (externalResult && resultRef.current) resultRef.current.scrollIntoView({ behavior: 'smooth', block: 'start' }); }, [externalResult]);

            useEffect(() => {
                if (externalResult) {
                    const savedItem = savedWords.find(w => w.word === externalResult.word);
                    if (savedItem) {
                        if (savedItem.tips !== externalResult.tips || savedItem.audioUrl !== externalResult.audioUrl || (!savedItem.example && externalResult.example)) {
                            onUpdateWord(externalResult);
                        }
                    }
                }
            }, [externalResult, savedWords, onUpdateWord]);

            const currentData = externalResult;
            const isSaved = currentData && savedWords.some(w => w.word === currentData.word);

            const resetToHome = () => {
                searchIdRef.current++; setExternalResult(null); setTerm(''); setLoading(false); setIsEnriching(false);
                if (inputRef.current) inputRef.current.focus();
            };

            return (
                <div className="fade-in">
                    <div className="mb-8 mt-2">
                        <form onSubmit={handleSearch} className="relative">
                            <input ref={inputRef} type="text" value={term} onChange={(e) => setTerm(e.target.value)} className="neu-input w-full p-4 pl-12 text-lg text-[#258FAF] placeholder-gray-400" placeholder="単語/フレーズを入力" />
                            <i className="fas fa-search absolute left-5 top-5 text-gray-400"></i>
                            
                            {hasApiKey && (
                                <div className={`absolute top-2 w-12 h-12 flex items-center justify-center text-gray-300 pointer-events-none transition-all duration-300 ${term ? 'right-[5.5rem]' : 'right-[3.5rem]'}`}>
                                    <i className="fas fa-robot"></i>
                                </div>
                            )}

                            {term && (
                                <button type="button" onClick={() => {setTerm(''); inputRef.current.focus();}} className="absolute right-14 top-2 w-12 h-12 flex items-center justify-center text-gray-400 hover:text-gray-600">
                                    <i className="fas fa-times"></i>
                                </button>
                            )}
                            <button type="submit" className="absolute right-2 top-2 bg-[#258FAF] text-white w-12 h-12 flex items-center justify-center rounded-xl shadow-md active:scale-95 transition-transform"><i className="fas fa-arrow-right"></i></button>
                        </form>
                    </div>

                    {loading && <div className="flex flex-col items-center justify-center py-12"><div className="animate-spin rounded-full h-10 w-10 border-b-2 border-[#258FAF] mb-4"></div><p className="text-sm text-gray-500 animate-pulse">検索中...</p></div>}
                    {!loading && !currentData && <div className="text-center py-20 opacity-40 select-none"><div className="neu-flat w-32 h-32 rounded-full flex items-center justify-center mx-auto mb-6 text-[#258FAF]"><img src="https://conizm3.github.io/wordrobe/images/wordrobe-lptop.png" className="w-20 h-20 opacity-60 object-contain" alt="Search" /></div><p className="font-bold text-gray-500"></p></div>}

                    {currentData && (
                        <div ref={resultRef} className="neu-flat p-5 md:p-6 mb-8 fade-in relative mt-8 allow-select">
                            {isFromList && <button onClick={onBack} className="absolute -top-5 left-1/2 transform -translate-x-1/2 bg-white text-gray-400 w-10 h-10 rounded-full shadow-md flex items-center justify-center z-20 hover:text-[#258FAF] transition-colors border border-gray-100"><i className="fas fa-times text-lg"></i></button>}
                            <div className="flex justify-between items-start mb-6 border-b border-gray-100 pb-4">
                                <div>
                                    <h2 className="text-2xl md:text-4xl font-bold text-[#258FAF] break-all mb-1">{currentData.word}</h2>
                                    {currentData.pronunciation && <div className="mb-2"><span className="text-xs md:text-sm text-gray-500 font-mono bg-gray-100 px-2 py-0.5 rounded">{currentData.pronunciation}</span></div>}
                                    <p className="text-lg md:text-xl font-bold text-gray-700 mt-3">{currentData.translation}</p>
                                </div>
                                <div className="flex gap-3">
                                    <button onClick={() => speak(currentData.word, currentData.audioUrl)} className="neu-btn w-10 h-10 flex items-center justify-center rounded-full text-[#258FAF]"><i className="fas fa-volume-up"></i></button>
                                    <button onClick={() => onSaveWord(currentData)} className={`neu-btn w-10 h-10 flex items-center justify-center rounded-full ${isSaved ? 'text-yellow-500 neu-pressed' : 'text-gray-400'}`}><i className="fas fa-bookmark"></i></button>
                                </div>
                            </div>

                            {currentData.aiData && (
                                <div className="mb-6 fade-in">
                                    <div className="neu-pressed bg-[#258FAF]/5 p-4 rounded-xl border border-[#258FAF]/20 relative overflow-hidden">
                                        <div className="absolute top-0 left-0 w-1 h-full bg-[#258FAF]"></div>
                                        <div className="flex gap-2 items-start mb-3">
                                            <i className="fas fa-robot text-[#258FAF] mt-1"></i>
                                            <p className="text-xs font-bold text-[#258FAF]">AI Tips</p>
                                        </div>
                                        <div className="space-y-4 pl-2">
                                            {currentData.aiData.definition && (
                                                <div>
                                                    <span className="text-[10px] font-bold text-[#258FAF] bg-white/50 px-2 py-0.5 rounded border border-[#258FAF]/10">定義</span>
                                                    <p className="text-sm text-gray-700 mt-1 leading-relaxed font-bold">{currentData.aiData.definition}</p>
                                                </div>
                                            )}
                                            {currentData.aiData.exampleEn && (
                                                <div>
                                                    <span className="text-[10px] font-bold text-[#258FAF] bg-white/50 px-2 py-0.5 rounded border border-[#258FAF]/10">例文</span>
                                                    <p className="text-sm text-gray-700 mt-1 leading-relaxed italic">"{currentData.aiData.exampleEn}"</p>
                                                    {currentData.aiData.exampleJa && <p className="text-xs text-gray-500 mt-1">{currentData.aiData.exampleJa}</p>}
                                                </div>
                                            )}
                                            {currentData.aiData.supplement && (
                                                <div>
                                                    <span className="text-[10px] font-bold text-[#258FAF] bg-white/50 px-2 py-0.5 rounded border border-[#258FAF]/10">補足</span>
                                                    <p className="text-sm text-gray-600 mt-1 leading-relaxed">{currentData.aiData.supplement}</p>
                                                </div>
                                            )}
                                        </div>
                                    </div>
                                </div>
                            )}

                            {aiError && (
                                <div className="mb-6 fade-in">
                                    <div className="neu-pressed bg-red-50 p-4 rounded-xl border border-red-100 relative overflow-hidden">
                                        <div className="absolute top-0 left-0 w-1 h-full bg-red-400"></div>
                                        <div className="flex gap-2 items-start pl-2 text-red-400">
                                            <i className="fas fa-exclamation-triangle mt-1 shrink-0"></i>
                                            <div className="text-xs space-y-1">
                                                <p className="font-bold">AIからの返事を受け取れませんでした。</p>
                                                <p>APIキーの設定や、使用上限（利用枠）に達していないか、一度ご確認ください。</p>
                                                <div className="pt-1 opacity-80 text-[10px] leading-relaxed">
                                                    <p className="font-bold">Unable to receive a response from AI.</p>
                                                    <p>Please check your API key settings or if the usage limit has been reached.</p>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            )}

                            <div className="space-y-8">
                                {currentData.meanings && currentData.meanings.length > 0 ? (
                                    currentData.meanings.map((m, idx) => (
                                        <div key={idx} className="relative">
                                            <div className="flex items-center gap-2 mb-3"><span className="px-3 py-1 bg-slate-100 text-slate-600 text-xs font-bold rounded-md uppercase">{m.partOfSpeech.toUpperCase()}</span></div>
                                            <div className="pl-2 border-l-2 border-[#258FAF]/30 space-y-6">
                                                {m.definitions.map((def, dIdx) => (
                                                    <div key={dIdx}>
                                                        <p className="text-gray-800 font-bold mb-1 leading-relaxed text-sm md:text-base"><span className="text-[#258FAF] mr-1">{dIdx + 1}.</span> {def.ja}</p>
                                                        <p className="text-xs text-gray-400 mb-2 pl-4">{def.en}</p>
                                                    </div>
                                                ))}
                                            </div>
                                        </div>
                                    ))
                                ) : (<div className="text-center text-gray-400 text-sm">詳細な定義はありません。<br/><span className="text-xs">翻訳: {currentData.translation}</span></div>)}
                                
                                {currentData.synonyms && currentData.synonyms.length > 0 && (
                                    <div className="pt-4 border-t border-gray-100">
                                        <span className="text-xs font-bold text-gray-400 block mb-2">類義語 (Synonyms)</span>
                                        <div className="flex flex-wrap gap-2">{currentData.synonyms.slice(0,8).map((syn, i) => <span key={i} className="neu-pressed px-3 py-1 text-xs text-gray-500 rounded-lg">{syn}</span>)}</div>
                                    </div>
                                )}
                            </div>
                        </div>
                    )}
                    
                    {!isFromList && currentData && (
                        <button onClick={resetToHome} className="fixed bottom-[100px] right-4 w-14 h-14 bg-[#258FAF] text-white rounded-full shadow-lg flex items-center justify-center z-[60] hover:bg-[#1d6f8c] transition-transform active:scale-95">
                            <i className="fas fa-search text-xl"></i>
                        </button>
                    )}
                </div>
            );
        };

        const WordListItem = ({ item, onSelect, onDelete, onToggleMemorized }) => {
            const clickTimeoutRef = useRef(null);

            const handleClick = (e) => {
                if (clickTimeoutRef.current) {
                    clearTimeout(clickTimeoutRef.current);
                    clickTimeoutRef.current = null;
                    onToggleMemorized(item);
                } else {
                    clickTimeoutRef.current = setTimeout(() => {
                        onSelect(item);
                        clickTimeoutRef.current = null;
                    }, 250);
                }
            };

            const isMem = item.isMemorized || false;

            return (
                <div onClick={handleClick} className={`neu-flat p-4 flex justify-between items-center cursor-pointer active:scale-[0.99] transition ${isMem ? 'opacity-40 grayscale bg-gray-100' : ''}`}>
                    <div className="overflow-hidden mr-2">
                        <div className="font-bold text-[#258FAF] text-lg">{item.word}</div>
                        <div className="text-sm text-gray-600 font-bold">{item.translation}</div>
                        {item.folder && (
                            <div className="text-[10px] text-gray-400 mt-1 bg-gray-100 inline-block px-2 py-0.5 rounded-md">
                                <i className="fas fa-folder mr-1"></i>{item.folder}
                            </div>
                        )}
                    </div>
                    <div className="flex gap-2 items-center">
                        <button className="neu-btn w-10 h-10 flex items-center justify-center rounded-full text-[#258FAF] shrink-0 relative z-10" onClick={(e) => { e.stopPropagation(); speak(item.word, item.audioUrl); }}><i className="fas fa-volume-up"></i></button>
                        <button className="neu-btn w-10 h-10 flex items-center justify-center rounded-full text-gray-400 hover:text-red-400 shrink-0 relative z-10" onClick={(e) => { e.stopPropagation(); onDelete(item.word); }}><i className="fas fa-trash"></i></button>
                    </div>
                </div>
            );
        };

        const ListView = ({ savedWords, folders, onDeleteWord, onSelectWord, onToggleMemorized, onManageFolders }) => {
            const [selectedFolder, setSelectedFolder] = useState('ALL');
            const [isFilterMenuOpen, setIsFilterMenuOpen] = useState(false);

            const displayedWords = selectedFolder === 'ALL' 
                ? savedWords 
                : savedWords.filter(w => w.folder === selectedFolder);

            if (!savedWords || savedWords.length === 0) {
                return <div className="text-center py-20 text-gray-400 fade-in"><p>保存された単語はありません</p></div>;
            }
            
            return (
                <div className="fade-in">
                    <div className="flex justify-between items-center mb-4 relative">
                        <h2 className="text-xl font-bold text-[#258FAF] ml-2">単語棚 <span className="text-sm font-normal text-gray-500 ml-1">({displayedWords.length})</span></h2>
                        <div className="flex items-center">
                            <div className="relative">
                                <button onClick={() => setIsFilterMenuOpen(!isFilterMenuOpen)} className="text-gray-400 hover:text-[#258FAF] p-2 flex items-center gap-1">
                                    <span className="text-xs font-bold">{selectedFolder === 'ALL' ? 'ALL' : selectedFolder}</span>
                                    <i className="fas fa-filter"></i>
                                </button>
                                {isFilterMenuOpen && (
                                    <div className="absolute top-full right-0 mt-2 bg-white border border-gray-100 rounded-xl shadow-xl overflow-hidden w-40 z-30 fade-in">
                                        <button 
                                            onClick={() => { setSelectedFolder('ALL'); setIsFilterMenuOpen(false); }}
                                            className={`w-full text-left px-4 py-3 text-xs font-bold border-b border-gray-50 hover:bg-gray-50 ${selectedFolder === 'ALL' ? 'text-[#258FAF] bg-[#258FAF]/5' : 'text-gray-600'}`}
                                        >
                                            ALL
                                        </button>
                                        {folders.map(folder => (
                                            <button 
                                                key={folder} 
                                                onClick={() => { setSelectedFolder(folder); setIsFilterMenuOpen(false); }}
                                                className={`w-full text-left px-4 py-3 text-xs font-bold border-b border-gray-50 hover:bg-gray-50 ${selectedFolder === folder ? 'text-[#258FAF] bg-[#258FAF]/5' : 'text-gray-600'}`}
                                            >
                                                <i className="fas fa-folder mr-2 text-gray-300"></i>{folder}
                                            </button>
                                        ))}
                                    </div>
                                )}
                            </div>
                            <button onClick={onManageFolders} className="text-gray-400 hover:text-[#258FAF] p-2">
                                <i className="fas fa-cog"></i>
                            </button>
                        </div>
                    </div>

                    <div className="space-y-4">
                        {displayedWords.map((item, idx) => (
                            <WordListItem 
                                key={idx} 
                                item={item} 
                                onSelect={onSelectWord} 
                                onDelete={onDeleteWord} 
                                onToggleMemorized={onToggleMemorized} 
                            />
                        ))}
                        {displayedWords.length === 0 && (
                            <div className="text-center py-10 text-gray-400 text-sm">
                                このフォルダは空です
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        const ReviewView = ({ savedWords, folderList, onFinish, openAlert }) => {
            const [isStarted, setIsStarted] = useState(false);
            const [testMode, setTestMode] = useState('en_ja'); 
            const [targetFolder, setTargetFolder] = useState('ALL');
            const [queue, setQueue] = useState([]);
            const [index, setIndex] = useState(0);
            const [isFlipped, setIsFlipped] = useState(false);
            const [isExiting, setIsExiting] = useState(false);
            const [isSwipeAction, setIsSwipeAction] = useState(null); 
            const [isFolderMenuOpen, setIsFolderMenuOpen] = useState(false);
            const touchStartX = useRef(null);
            const cardRef = useRef(null);

            const startReview = () => {
                const validWords = savedWords.filter(w => {
                    const matchesFolder = targetFolder === 'ALL' || w.folder === targetFolder;
                    return matchesFolder && !w.isMemorized;
                });

                if (validWords.length === 0) return openAlert('復習対象の単語がありません');
                const shuffled = [...validWords].sort(() => Math.random() - 0.5);
                setQueue(shuffled);
                setIndex(0);
                setIsFlipped(false);
                setIsStarted(true);
            };

            const handleNext = (isClear) => {
                if (!isClear) {
                    setQueue(prev => {
                        const current = prev[index];
                        return [...prev, current];
                    });
                }
                setIsExiting(true);
                setTimeout(() => {
                    setIsFlipped(false);
                    setIndex(prev => prev + 1);
                    setIsExiting(false);
                    setIsSwipeAction(null);
                    if (cardRef.current) cardRef.current.style.transform = ''; 
                }, 250);
            };

            useEffect(() => {
               if (isStarted && index >= queue.length) {
                   setIsStarted(false);
                   setQueue([]);
                   setIndex(0);
                   openAlert('復習完了！お疲れ様でした。');
                   onFinish();
               }
            }, [index, queue.length, isStarted]);

            useEffect(() => {
                if (isStarted && queue[index] && testMode === 'en_ja') {
                     const timer = setTimeout(() => {
                         if (!isFlipped) speak(queue[index].word, queue[index].audioUrl);
                     }, 300);
                     return () => clearTimeout(timer);
                }
            }, [index, isStarted, testMode]);

            const toggleFlip = () => {
                if (!isFlipped) {
                     const wordToSpeak = queue[index].word;
                     speak(wordToSpeak, queue[index].audioUrl);
                }
                setIsFlipped(!isFlipped);
            };

            const onTouchStart = (e) => { touchStartX.current = e.touches[0].clientX; };
            const onTouchMove = (e) => {
                if (!touchStartX.current || !cardRef.current || isExiting) return;
                const currentX = e.touches[0].clientX;
                const diff = currentX - touchStartX.current;
                const rotate = diff * 0.05;
                cardRef.current.style.transform = `translateX(${diff}px) rotate(${rotate}deg)`;
                if (diff > 50) setIsSwipeAction('clear');
                else if (diff < -50) setIsSwipeAction('unclear');
                else setIsSwipeAction(null);
            };
            const onTouchEnd = (e) => {
                if (!touchStartX.current || !cardRef.current) return;
                const touchEndX = e.changedTouches[0].clientX;
                const distance = touchStartX.current - touchEndX;
                if (Math.abs(distance) > 100) { 
                    if (distance > 0) handleNext(false); else handleNext(true); 
                } else {
                    cardRef.current.style.transform = '';
                    setIsSwipeAction(null);
                }
                touchStartX.current = null;
            };

            if (!isStarted) {
                return (
                    <div className="h-full flex flex-col justify-center items-center text-center fade-in">
                        <h2 className="text-2xl font-bold mb-4 text-[#258FAF]">Review Mode</h2>
                        <div className="neu-flat w-40 h-40 rounded-full flex items-center justify-center mb-8 text-[#258FAF]">
                            <svg width="60" height="60" viewBox="0 0 24 24" fill="currentColor">
                                <g transform="rotate(-45 12 12)">
                                    <path fillRule="evenodd" clipRule="evenodd" d="M9 2H13L17 6V22H5V6L9 2ZM11 7.5C12.38 7.5 13.5 6.38 13.5 5C13.5 3.62 12.38 2.5 11 2.5C9.62 2.5 8.5 3.62 8.5 5C8.5 6.38 9.62 7.5 11 7.5Z" stroke="currentColor" strokeWidth="1.5" strokeLinejoin="round" />
                                </g>
                            </svg>
                        </div>
                        
                        <div className="flex gap-4 mb-4 bg-white p-1 rounded-lg shadow-inner w-72">
                            <button onClick={() => setTestMode('en_ja')} className={`flex-1 px-4 py-2 rounded-lg text-xs font-bold transition-all ${testMode === 'en_ja' ? 'bg-[#258FAF] text-white shadow-md' : 'text-gray-400'}`}>英 → 日</button>
                            <button onClick={() => setTestMode('ja_en')} className={`flex-1 px-4 py-2 rounded-lg text-xs font-bold transition-all ${testMode === 'ja_en' ? 'bg-[#258FAF] text-white shadow-md' : 'text-gray-400'}`}>日 → 英</button>
                        </div>

                        <div className="relative mb-8 w-72 z-20">
                            <button 
                                onClick={() => setIsFolderMenuOpen(!isFolderMenuOpen)}
                                className="w-full neu-flat text-gray-700 font-bold py-3 px-4 rounded-lg flex items-center justify-between text-xs active:scale-95 transition-transform"
                            >
                                <span className="flex items-center gap-2">
                                    <i className="fas fa-folder text-[#258FAF]"></i>
                                    {targetFolder === 'ALL' ? 'すべてのフォルダ' : targetFolder}
                                </span>
                                <i className={`fas fa-chevron-down transition-transform ${isFolderMenuOpen ? 'rotate-180' : ''} text-gray-400`}></i>
                            </button>
                            
                            {isFolderMenuOpen && (
                                <div className="absolute top-full left-0 w-full mt-2 bg-white border border-gray-100 rounded-xl shadow-xl overflow-hidden max-h-[130px] overflow-y-auto z-[60] fade-in">
                                    <button 
                                        onClick={() => { setTargetFolder('ALL'); setIsFolderMenuOpen(false); }}
                                        className={`w-full text-left px-4 py-3 text-xs font-bold border-b border-gray-50 hover:bg-gray-50 ${targetFolder === 'ALL' ? 'text-[#258FAF] bg-[#258FAF]/5' : 'text-gray-600'}`}
                                    >
                                        すべてのフォルダ
                                    </button>
                                    {folderList.map(f => (
                                        <button 
                                            key={f} 
                                            onClick={() => { setTargetFolder(f); setIsFolderMenuOpen(false); }}
                                            className={`w-full text-left px-4 py-3 text-xs font-bold border-b border-gray-50 hover:bg-gray-50 ${targetFolder === f ? 'text-[#258FAF] bg-[#258FAF]/5' : 'text-gray-600'}`}
                                        >
                                            <i className="fas fa-folder mr-2 text-gray-300"></i>{f}
                                        </button>
                                    ))}
                                </div>
                            )}
                        </div>

                        <button onClick={startReview} className="bg-[#258FAF] text-white w-72 py-4 rounded-lg font-bold shadow-lg active:scale-95 transition-transform">テストを開始</button>
                    </div>
                );
            }

            const currentCard = queue[index];
            if (!currentCard) return null;
            const questionText = testMode === 'en_ja' ? currentCard.word : currentCard.translation;
            const answerMain = testMode === 'en_ja' ? currentCard.translation : currentCard.word;

            return (
                <div className="h-full flex flex-col items-center justify-center pb-4 relative fade-in overflow-hidden">
                    <div ref={cardRef} className={`w-full max-w-sm h-[420px] card-flip cursor-pointer ${isFlipped ? 'flipped' : ''} ${isExiting ? (isSwipeAction === 'clear' ? 'slide-out-right' : 'slide-out-left') : 'slide-in-right'}`} onClick={toggleFlip} onTouchStart={onTouchStart} onTouchMove={onTouchMove} onTouchEnd={onTouchEnd} key={index}>
                        <div className="card-inner">
                            <div className="card-front neu-flat flex flex-col items-center justify-center p-8 text-center bg-[#F8FAFC] relative">
                                <span className="absolute top-6 left-6 text-xs font-bold text-gray-400">QUESTION</span>
                                <div className="flex-1 flex flex-col justify-center items-center w-full">
                                    <h2 className="text-4xl font-bold text-[#258FAF] break-all">{questionText}</h2>
                                    {testMode === 'en_ja' && (
                                        <button onClick={(e) => { e.stopPropagation(); speak(currentCard.word, currentCard.audioUrl); }} className="neu-btn w-12 h-12 flex items-center justify-center rounded-full text-[#258FAF] mt-8">
                                            <i className="fas fa-volume-up"></i>
                                        </button>
                                    )}
                                </div>
                                {isSwipeAction === 'clear' && <div className="absolute top-10 right-10 border-4 border-[#258FAF] text-[#258FAF] font-black text-2xl p-2 rounded transform rotate-12 opacity-80 pointer-events-none">CLEAR</div>}
                                {isSwipeAction === 'unclear' && <div className="absolute top-10 left-10 border-4 border-gray-400 text-gray-400 font-black text-2xl p-2 rounded transform -rotate-12 opacity-80 pointer-events-none">UNCLEAR</div>}
                                <div className="absolute bottom-6 w-full flex flex-col items-center gap-2">
                                    <p className="text-xs text-gray-400 opacity-60">タップして答えを表示</p>
                                    <div className="md:hidden text-gray-300 flex items-center mt-1 gap-2 w-full justify-center px-4">
                                        <span className="text-lg font-bold text-gray-400 opacity-80">✕　</span>
                                        <i className="fas fa-chevron-left opacity-50 text-xs"></i>
                                        <div className="mx-2 flex flex-col items-center">
                                            <i className="fas fa-hand-pointer text-2xl text-[#258FAF] opacity-80"></i>
                                            <span className="text-[8px] text-gray-400 mt-1">swipe</span>
                                        </div>
                                        <i className="fas fa-chevron-right opacity-50 text-xs"></i>
                                        <span className="text-lg font-bold text-[#258FAF] opacity-80">　◯</span>
                                    </div>
                                </div>
                            </div>
                            <div className="card-back neu-flat flex flex-col items-center justify-center p-8 text-center bg-gradient-to-b from-[#F8FAFC] to-white">
                                <span className="absolute top-6 left-6 text-xs font-bold text-[#258FAF]">ANSWER</span>
                                <h3 className="text-2xl font-bold text-gray-700 mb-4">{answerMain}</h3>
                                <div className="w-full overflow-y-auto max-h-32 text-sm text-gray-500 mb-4 px-4 space-y-2">
                                    {currentCard.meanings && currentCard.meanings.length > 0 ? currentCard.meanings.map((m, i) => <p key={i}><span className="font-bold">{m.partOfSpeech}:</span> {m.definitions[0].ja}</p>) : <p>{currentCard.definition}</p>}
                                </div>
                                <button onClick={(e) => { e.stopPropagation(); speak(currentCard.word, currentCard.audioUrl); }} className="neu-btn w-12 h-12 flex items-center justify-center rounded-full mt-2 text-[#258FAF]">
                                    <i className="fas fa-volume-up"></i>
                                </button>
                            </div>
                        </div>
                    </div>
                    
                    <div className="w-full max-w-sm mt-4 md:mt-8 flex gap-4 hidden md:flex">
                        <button onClick={() => handleNext(false)} className="flex-1 bg-slate-200 text-slate-600 py-4 rounded-2xl font-bold shadow-lg active:scale-95 transition-transform flex items-center justify-center gap-2"><i className="fas fa-times"></i> Unclear</button>
                        <button onClick={() => handleNext(true)} className="flex-1 bg-[#258FAF] text-white py-4 rounded-2xl font-bold shadow-lg active:scale-95 transition-transform flex items-center justify-center gap-2"><i className="far fa-circle"></i> Clear</button>
                    </div>
                </div>
            );
        };

        const App = () => {
            const [tab, setTab] = useState('search');
            const [savedWords, setSavedWords] = useState(() => {
                try {
                    const local = localStorage.getItem('aitan_words');
                    return local ? JSON.parse(local) : [];
                } catch (e) {
                    console.error("Data Parse Error, resetting.", e);
                    return [];
                }
            });
            const [folders, setFolders] = useState(() => {
                try {
                    const local = localStorage.getItem('aitan_folders');
                    return local ? JSON.parse(local) : ['main'];
                } catch (e) {
                    return ['main'];
                }
            });
            const [toastMsg, setToastMsg] = useState(null);
            const [searchResult, setSearchResult] = useState(null);
            const [searchViewKey, setSearchViewKey] = useState(0);
            const [isSettingsOpen, setIsSettingsOpen] = useState(false);
            const [isFolderModalOpen, setIsFolderModalOpen] = useState(false);
            const [isFolderManagerOpen, setIsFolderManagerOpen] = useState(false);
            const [currentSavedWord, setCurrentSavedWord] = useState(null);
            const [isFromList, setIsFromList] = useState(false);
            const [dialog, setDialog] = useState({ isOpen: false, type: 'alert', message: '', onConfirm: null });
            const [user, setUser] = useState(null);
            const [isCloudSynced, setIsCloudSynced] = useState(false);
            
            const [isFirstLaunch, setIsFirstLaunch] = useState(() => {
                return localStorage.getItem('is_first_launch_v1') !== 'false';
            });
            
            const handleAgreeTOS = () => {
                localStorage.setItem('is_first_launch_v1', 'false');
                setIsFirstLaunch(false);
            };

            const openAlert = (msg) => setDialog({ isOpen: true, type: 'alert', message: msg, onConfirm: () => setDialog(prev => ({ ...prev, isOpen: false })) });
            const openConfirm = (msg, onConfirm) => setDialog({ isOpen: true, type: 'confirm', message: msg, onConfirm: () => { onConfirm(); setDialog(prev => ({ ...prev, isOpen: false })); } });

            // Ensure folders persist correctly
            useEffect(() => {
                localStorage.setItem('aitan_folders', JSON.stringify(folders));
            }, [folders]);

            // Migration effect: Ensure existing data has folder 'main' if undefined
            useEffect(() => {
                const needsMigration = savedWords.some(w => !w.folder);
                if (needsMigration) {
                    setSavedWords(prev => prev.map(w => !w.folder ? { ...w, folder: 'main' } : w));
                    
                    // Also update IndexedDB
                    db.words.filter(w => !w.folder).toArray().then(wordsToUpdate => {
                        if (wordsToUpdate.length > 0) {
                            db.transaction('rw', db.words, async () => {
                                for (const word of wordsToUpdate) {
                                    await db.words.update(word.id, { folder: 'main' });
                                }
                            });
                        }
                    });
                }
            }, [savedWords]);

            useEffect(() => {
                if (auth) {
                    auth.onAuthStateChanged(async (u) => {
                        setUser(u);
                        if (u) {
                            setIsCloudSynced(false);
                            setToastMsg('ログインしました');
                            try {
                                const doc = await db_firebase.collection('users').doc(u.uid).get();
                                if (doc.exists) {
                                    const cloudWords = doc.data().words || [];
                                    
                                    await db.transaction('rw', db.words, db.deleted_words, async () => {
                                        const localWords = await db.words.toArray();
                                        const localWordMap = new Map(localWords.map(w => [w.word, w]));
                                        
                                        const deletedItems = await db.deleted_words.toArray();
                                        const deletedSet = new Set(deletedItems.map(d => d.word));

                                        const wordsToPut = [];
                                        for (const cw of cloudWords) {
                                            if (!localWordMap.has(cw.word) && !deletedSet.has(cw.word)) {
                                                const { id, ...wordWithoutId } = cw;
                                                wordsToPut.push(wordWithoutId);
                                            }
                                        }
                                        if (wordsToPut.length > 0) {
                                            await db.words.bulkAdd(wordsToPut);
                                        }
                                    });
                                    const allWords = await db.words.toArray();
                                    allWords.sort((a,b) => (b.addedAt || 0) - (a.addedAt || 0));
                                    
                                    // Apply migration to loaded data as well
                                    const migratedWords = allWords.map(w => !w.folder ? { ...w, folder: 'main' } : w);
                                    setSavedWords(migratedWords);
                                    
                                    const uniqueFolders = new Set(['main', ...migratedWords.map(w => w.folder || 'main')]);
                                    setFolders(Array.from(uniqueFolders));
                                    
                                    setToastMsg('データを同期しました');
                                }
                                setIsCloudSynced(true);
                            } catch (err) {
                                console.error("Sync Error:", err);
                                setIsCloudSynced(true);
                            }
                        } else {
                            setIsCloudSynced(false);
                        }
                    });
                }
            }, []);

            useEffect(() => {
                localStorage.setItem('aitan_words', JSON.stringify(savedWords));
                if (user && db_firebase && isCloudSynced) {
                    db_firebase.collection('users').doc(user.uid).set({
                        words: savedWords,
                        updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                    }, { merge: true }).catch(e => console.error("Cloud Save Error", e));
                }
            }, [savedWords, user, isCloudSynced]);

            const handleLogin = () => {
                if (!auth) return openAlert("クラウド機能は現在利用できません");
                const provider = new firebase.auth.GoogleAuthProvider();
                auth.signInWithPopup(provider).catch(e => openAlert(`ログインエラー: ${e.message}`));
            };

            const handleLogout = () => {
                if(!auth) return;
                auth.signOut().then(() => {
                    setToastMsg('ログアウトしました');
                    setUser(null);
                    setIsCloudSynced(false);
                });
            };

            const handleUpdateWord = async (wordData) => {
                setSavedWords(prev => prev.map(w => w.word === wordData.word ? { ...w, ...wordData } : w));
                try {
                    const wordInDb = await db.words.where('word').equals(wordData.word).first();
                    if (wordInDb) {
                        const { id, ...updates } = wordData;
                        await db.words.update(wordInDb.id, updates);
                    }
                } catch (e) {}
            };

            const handleToggleMemorized = async (wordData) => {
                const newStatus = !wordData.isMemorized;
                const updatedWord = { ...wordData, isMemorized: newStatus };
                setSavedWords(prev => prev.map(w => w.word === wordData.word ? updatedWord : w));
                try {
                    const wordInDb = await db.words.where('word').equals(wordData.word).first();
                    if (wordInDb) {
                        await db.words.update(wordInDb.id, { isMemorized: newStatus });
                    }
                } catch (e) {}
            };

            const handleSaveWord = async (wordData) => {
                try {
                    const exists = savedWords.some(w => w.word === wordData.word);
                    if (exists) {
                        const wordInDb = await db.words.where('word').equals(wordData.word).first();
                        if(wordInDb) await db.words.delete(wordInDb.id);
                        setSavedWords(prev => prev.filter(w => w.word !== wordData.word));
                        setToastMsg('削除しました');
                    } else {
                        const newWord = { ...wordData, addedAt: Date.now(), folder: 'main' };
                        
                        await db.deleted_words.delete(newWord.word).catch(() => {});

                        const id = await db.words.add(newWord); 
                        setSavedWords(prev => [{ ...newWord, id }, ...prev]);
                        setToastMsg('保存しました');
                        
                        setCurrentSavedWord(newWord);
                        setIsFolderModalOpen(true);
                    }
                } catch (e) { openAlert("保存エラー発生"); }
            };

            const handleChangeFolder = async (folderName) => {
                if (!currentSavedWord) return;
                const updatedWord = { ...currentSavedWord, folder: folderName };
                
                setSavedWords(prev => prev.map(w => w.word === updatedWord.word ? updatedWord : w));
                
                try {
                    const wordInDb = await db.words.where('word').equals(updatedWord.word).first();
                    if (wordInDb) {
                        await db.words.update(wordInDb.id, { folder: folderName });
                    }
                } catch (e) {}
                
                setToastMsg(`「${folderName}」に移動しました`);
                setIsFolderModalOpen(false);
            };

            const handleCreateFolder = (newFolderName) => {
                if (!folders.includes(newFolderName)) {
                    setFolders(prev => [...prev, newFolderName]);
                }
                handleChangeFolder(newFolderName);
            };

            const handleRenameFolder = async (oldName, newName) => {
                if (folders.includes(newName)) return openAlert('同じ名前のフォルダが既に存在します');
                setFolders(prev => prev.map(f => f === oldName ? newName : f));
                
                const updatedWords = savedWords.map(w => w.folder === oldName ? { ...w, folder: newName } : w);
                setSavedWords(updatedWords);

                await db.transaction('rw', db.words, async () => {
                    const wordsToUpdate = await db.words.where('folder').equals(oldName).toArray();
                    for (const word of wordsToUpdate) {
                        await db.words.update(word.id, { folder: newName });
                    }
                });
            };

            const handleDeleteFolder = async (folderName) => {
                openConfirm(`フォルダ「${folderName}」を削除しますか？\n中身は「main」フォルダに移動します。`, async () => {
                    setFolders(prev => prev.filter(f => f !== folderName));
                    
                    const updatedWords = savedWords.map(w => w.folder === folderName ? { ...w, folder: 'main' } : w);
                    setSavedWords(updatedWords);

                    await db.transaction('rw', db.words, async () => {
                        const wordsToUpdate = await db.words.where('folder').equals(folderName).toArray();
                        for (const word of wordsToUpdate) {
                            await db.words.update(word.id, { folder: 'main' });
                        }
                    });
                });
            };

            const handleDeleteWord = (word) => {
                openConfirm(`「${word}」を削除しますか？`, async () => {
                    const wordInDb = await db.words.where('word').equals(word).first();
                    if(wordInDb) {
                        await db.words.delete(wordInDb.id);
                        await db.deleted_words.put({ word: word });
                    }
                    setSavedWords(prev => prev.filter(w => w.word !== word));
                });
            };

            const handleListClick = (wordData) => {
                setSearchResult(wordData);
                setTab('search');
                setIsFromList(true); 
            };
            
            const resetToHome = () => {
                setTab('search');
                setSearchResult(null);
                setIsFromList(false);
                setSearchViewKey(prev => prev + 1); 
            };

            const handleBack = () => {
                setSearchResult(null);
                if (isFromList) {
                    setTab('list');
                    setIsFromList(false);
                }
            };

            const handleExport = () => {
                const dataStr = JSON.stringify(savedWords, null, 2);
                const blob = new Blob([dataStr], {type: "application/json"});
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `backup.json`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            };

            const handleImport = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const imported = JSON.parse(event.target.result);
                        if (Array.isArray(imported)) {
                            openConfirm('データを上書きしますか？', () => {
                                setSavedWords(imported);
                                
                                const uniqueFolders = new Set(['main', ...imported.map(w => w.folder || 'main')]);
                                setFolders(Array.from(uniqueFolders));
                                
                                setToastMsg('復元しました');
                                setIsSettingsOpen(false);
                            });
                        }
                    } catch (error) { openAlert('読み込み失敗'); }
                };
                reader.readAsText(file);
            };

            const uiDisabledClass = isFirstLaunch ? 'pointer-events-none opacity-50' : '';


            return (
                <div className="h-screen-safe">
                    
                    {isFirstLaunch && <TOSModal isVisible={isFirstLaunch} onAgree={handleAgreeTOS} />}

                    <header className={`custom-header neu-flat ${uiDisabledClass}`}>
                        <div className="flex-1 flex justify-center items-center" onClick={resetToHome}>
                            <img src="https://conizm3.github.io/wordrobe/images/wordrobe-top.png" alt="wordrobe" className="h-8 md:h-12" />
                        </div>
                        <button onClick={(e) => { e.stopPropagation(); setIsSettingsOpen(true); }} className="absolute right-5 md:right-10 text-gray-400 hover:text-[#258FAF]"><i className="fas fa-cog"></i></button>
                    </header>

                    <main className={`custom-main main-with-ad ${uiDisabledClass}`}>
                        {tab === 'search' && <SearchView key={searchViewKey} savedWords={savedWords} onSaveWord={handleSaveWord} setToast={setToastMsg} externalResult={searchResult} setExternalResult={setSearchResult} isFromList={isFromList} onBack={handleBack} openAlert={openAlert} onUpdateWord={handleUpdateWord} />}
                        {tab === 'list' && <ListView savedWords={savedWords} folders={folders} onDeleteWord={handleDeleteWord} onSelectWord={handleListClick} onToggleMemorized={handleToggleMemorized} onManageFolders={() => setIsFolderManagerOpen(true)} />}
                        {tab === 'review' && <ReviewView savedWords={savedWords} folderList={folders} onFinish={resetToHome} openAlert={openAlert} />}
                    </main>

                    <SettingsModal isOpen={isSettingsOpen} onClose={() => setIsSettingsOpen(false)} onExport={handleExport} onImport={handleImport} user={user} onLogin={handleLogin} onLogout={handleLogout} openAlert={openAlert} openConfirm={openConfirm} />
                    <FolderSelectModal isOpen={isFolderModalOpen} onClose={() => setIsFolderModalOpen(false)} folders={folders} onSelectFolder={handleChangeFolder} onCreateFolder={handleCreateFolder} />
                    <FolderManagerModal isOpen={isFolderManagerOpen} onClose={() => setIsFolderManagerOpen(false)} folders={folders} onRename={handleRenameFolder} onDelete={handleDeleteFolder} />
                    <DialogModal isOpen={dialog.isOpen} type={dialog.type} message={dialog.message} onConfirm={dialog.onConfirm} onCancel={() => setDialog(prev => ({ ...prev, isOpen: false }))} />
                    
                    <nav className={`custom-nav neu-flat nav-bottom ${uiDisabledClass}`}>
                        <button onClick={() => resetToHome()} className={`nav-btn flex flex-col items-center w-1/3 ${tab === 'search' ? 'tab-active' : 'tab-inactive'}`}><div className={`w-10 h-10 flex items-center justify-center rounded-xl mb-1 transition-all ${tab === 'search' ? 'neu-pressed' : ''}`}><i className="fas fa-search text-lg"></i></div><span className="text-[10px] font-bold">検索</span></button>
                        <button onClick={() => setTab('review')} className={`nav-btn flex flex-col items-center w-1/3 ${tab === 'review' ? 'tab-active' : 'tab-inactive'}`}>
                            <div className={`w-10 h-10 flex items-center justify-center rounded-xl mb-1 transition-all ${tab === 'review' ? 'neu-pressed' : ''}`}>
                                <svg width="22" height="22" viewBox="0 0 24 24" fill="currentColor">
                                    <g transform="rotate(-45 12 12)">
                                        <path fillRule="evenodd" clipRule="evenodd" d="M9 2H13L17 6V22H5V6L9 2ZM11 7.5C12.38 7.5 13.5 6.38 13.5 5C13.5 3.62 12.38 2.5 11 2.5C9.62 2.5 8.5 3.62 8.5 5C8.5 6.38 9.62 7.5 11 7.5Z" stroke="currentColor" strokeWidth="1.5" strokeLinejoin="round" />
                                    </g>
                                </svg>
                            </div>
                            <span className="text-[10px] font-bold">復習</span>
                        </button>
                        <button onClick={() => setTab('list')} className={`nav-btn flex flex-col items-center w-1/3 ${tab === 'list' ? 'tab-active' : 'tab-inactive'}`}>
                            <div className={`w-10 h-10 flex items-center justify-center rounded-xl mb-1 transition-all ${tab === 'list' ? 'neu-pressed' : ''}`}>
                                <svg width="26" height="26" viewBox="0 0 24 24" fill="currentColor">
                                    <path fillRule="evenodd" clipRule="evenodd" d="M6 2H11V22H6C4.89543 22 4 21.1046 4 20V4C4 2.89543 4.89543 2 6 2ZM13 2H18C19.1046 2 20 2.89543 20 4V20C20 21.1046 19.1046 22 18 22H13V2ZM9 11C8.44772 11 8 11.4477 8 12C8 12.5523 8.44772 13 9 13C9.55228 13 10 12.5523 10 12C10 11.4477 9.55228 11 9 11ZM15 11C14.4477 11 14 11.4477 14 12C14 12.5523 14.4477 13 15 13C15.5523 13 16 12.5523 16 12C16 11.4477 15.5523 11 15 11Z" />
                                </svg>
                            </div>
                            <span className="text-[10px] font-bold">単語棚</span>
                        </button>
                    </nav>

                    {toastMsg && <Toast msg={toastMsg} onClose={() => setToastMsg(null)} />}
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
